seccomp
-------
```
Ubuntu 16.04
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
seccomp 함수는 바이너리 내부에서 특정 함수들에 대하여 실행 제한을 거는 함수이다. 

문제를 보면 read, write, exec 함수에 대해 실행 제한을 걸고 있다. 
사용자가 입력한 쉘코드에 대해 실행은 가능하지만, 필터링으로 인해 몇가지 시스템콜은 사용이 불가하다. 

이경우 seccomp에서 시스템콜을 필터링 하는 방식을 이용해 이를 우회해야 한다.
블랙리스트에 있는 시스템 콜 번호들이 필터링 된 다음, 
시스템 콜로 전달되는 숫자가 0x40000000과의 and 연산을 거쳤을때 0이 아니라면 
~0x40000000 과 and 연산을 진행한 결과값을 시스템 콜 번호로 사용한다. 
즉, 0x40001234 가 전달될 경우 0x40001234 & ~0x40000000 이므로 0x1234만 남게된다. (사실상 xor 연산)

이를 이용하여, 시스템 콜 번호를 전달할 떄 원하는 시스템콜의 번호를 그대로 넣는 대신에
~0x40000000 과 and 연산 이후에 남을 숫자를 계산하여 넣으면 되는 것. 

다시 바이너리로 돌아와서, 1번 선택시 쉘코드를 입력하고 , 2번 선택시에는 실행, 
3번 선택시에는 원하는 주소 위치에 원하는 값을 입력하게 만든다. 

seccomp로 인해 일반적인 쉘코드의 사용은 불가능한 상황이므로 , seccomp 필터 우회를 진행한다. 
./bin/sh 를 실행하는 쉘코드를 작성하거나, 
libc 주소를 얻어낼 수 있는 쉘코드를 작성하여 원샷가젯 실행을 유도해보자.

일단 모드가 strict 모드로 동작하므로, read/write의 사용만 가능한 상태. 
음? 근데 이러면 0x40000000 을 이용한 필터링 우회 대신, 그냥 write로 libc 가져오고 원샷가젯 사용해도 될것같다... 였는데 문제에서 libc를 안준다. 

문제에서 libc좀 안주면 어떤가. 운영체제 버전 아니까 그냥 write로 got에 원샷가젯 덮어쓰기 해보자. 
그러나 seccomp 로 인해 execve 실행이 불가하여 안된다. 

아, strict 모드로 되어있는걸 filter 모드로 교체할 수 있나? 
0x602090 주소는 mode 변수로 쓰이고, 1로 세팅되어 strict 모드로 함수가 동작하게 한다. 
이를 2번으로 바꾸면 filter 모드로 프로그램이 동작하게 될것.. 인데 그냥 에러가 발생한다.

근데 에러는 에러대로 발생하고 프로그램 진행은 또 그대로 된다.
이는 syscall_filter 함수에서 에러 발생시 exit이 아니라 return을 수행했기 때문. 

아무튼 0을 넣건 2를 넣건 prctl 함수 실행 자체를 망가트리면 더이상 seccomp가 동작하지 않으므로, 
일반 쉘코드의 실행도 가능해진다. 64비트 binsh 쉘코드를 실행시키면 끝. 

사실 이문제는 1번에서 syscall_filter를 실행하기 전에 
3번에서 원하는 주소의 값을 원하는대로 바꿀 수 있으므로
got를 덮어쓰건, 인자값을 바꾸건 prctl의 실행 자체를 막기만 하면 되는 문제였다 .













