smart pointer
-------------
```
Ubuntu 16.04.6 LTS
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE disabled
```

cpp에서는 스마트포인터라는 개념이 있는데, 
스마트포인터를 사용하면 자동으로 메모리의 할당과 해제가 이뤄지는 특징이 있다. 
객체가 소멸될 때 가리키고 있는 대상에 대해 자동으로 할당 해제를 진행하여 메모리 누수 문제를 해결하는 것. 

shared_ptr을 사용한 스마트 포인터는 각 객체별로 레퍼런스 카운트(참조 카운트)라는 변수를 가지고 있는데, 
해당 객체를 참조하는 스마트 포인터가 복사되거나 대입될 시 하나씩 증가하고,
복사하거나 대입된 임시 객체가 함수 호출 후 등의 이유로 소멸되면 참조 카운트가 감소한다. 
스마트 포인터에 의해 선언된 객체의 참조 카운트가 0이 되면 해당 객체는 할당 해제된다. 

그러나 이는 **스마트 포인터** 에 대해 복사나 대입이 이뤄졌을 때의 이야기이고, 
스마트포인터가 가리키고 있는 객체에 대해서는 통용되지 않는다. 
```
// 최초 생성시 초기 참조 카운트는 당연히 '1'
std::shared_ptr<Car> Car1( new Car() );
// 복사 -> 참조 카운트 '2'
std::shared_ptr<Car> Car2(Car1);
// 대입 -> 참조 카운트 '3'
std::shared_ptr<Car> Car3 = Car1;
```
위와 같은 방식으로 선언, 복사, 대입된 경우 Car()의 참조 카운트는 3이되고, 
복사한 스마트 포인터들이 소멸될때 카운트가 1씩 감소하여 0이 되면 Car()객체가 할당 해제되는 방식이다. 
```
Car *  = new oldcar();
// 최초 생성시 참조 카운트 1
std::shared_ptr<Car> Car1( oldcar() );
// 똑같은 oldcar() 객체를 참조하지만 복사나 대입이 아닌 생성이므로 참조 카운트 1
std::shared_ptr<Car> Car2( oldcar() );
```
동일한 객체를 참조했으나 복사/대입이 아닌 선언을 통한 생성이 이뤄졌으므로 참조카운트는 그대로며
각 스마트 포인터 원본마다 참조카운트를 각각 가진다. 즉, 두개의 스마트 포인터가 참조카운트 1을 각각 가지는 것.
따라서, 스마트 포인터 두개가 각각 소멸 될 때 마다 참조카운트는 1->0이 되어 oldcar() 객체가 할당 해제 된다. 
이미 할당 해제 된 경우라도, 참조카운트가 1에서 0으로 감소하면 다시 할당 해제가 이뤄져 더블프리 버그가 발생하게 된다. 

이런 문제를 방지하려면 맨 처음 예제처럼 스마트 포인터를 통해 새로운 스마트 포인터를 만들어야 한다는 이야기. 

이제 바이너리로 가보자. 다섯개를 선택할 수 있는데 각각 스마트포인터 변경, 삭제, 테스트, 게스트북 쓰기, 읽기 순이다. 
변경을 실행하면 원래 스마트 포인터의 내용인 apple을 banana나 mango 로 변경할 수 있다. 

이는 smart 객체가 내부적으로 fp라는 함수 포인터를 멤버로 가지고 있고, 
변경시에 특정 문자열을 출력하는 함수 포인터를 해당 멤버에 복사하는 것. 

삭제를 실행하면 선택한 스마트 포인터에 대해 reset()함수를 실행한다.
reset 함수는 스마트 포인터가 참조하는 객체를 다른 객체로 변경할 수있는 함수인데, 
인자를 주지 않으면 참조 포기가 발생하여 해당 스마트포인터가 소멸하고, 참조 카운트가 1 감소한다. 
이떄 smart 객체의 참조 카운트가 0이 될 테니 할당 해제가 발생하겠다. 

게스트북 쓰기 , 읽기의 경우는 전역변수 영역에 선언된 guestbook 변수를 읽고 쓰는 동작을 한다. 
이때 , 쓰기 시에 malloc 함수를 입력한 문자열의 길이만큼 실행하여 해당 공간에 문자열 복사를 진행한다. 

이제 메모리를 확인해보면, 0x20 힙을 세개 선언하고 먼저 선언된 청크에는 문자열을 출력하는 함수 주소를, 
그 다음 청크 두개에는 스마트 포인터가 각각 저장되는걸 볼 수 있다. 
스마트 포인터가 저장되는 청크는 포인터+0x10 위치에 **함수 주소가 저장된 힙 영역** 의 **주소**를 가지고 있다. 
test 에서 함수 호출시엔 저 영역을 참조 -> 힙영역 주소 가져옴 -> 해당 힙영역에 있는 함수 주소 가져옴 -> 호출
순으로 동작이 이뤄지는 듯. 

할당 해제시엔 둘 다 free를 진행하면서 해당 영역을 초기화하여 비운다.

동작을 해보며 메모리를 확인하자. 
포인터 삭제시에 함수 주소 포인터와 스마트 포인터가 각각 할당 해제되고, 
이후 0x20 바이트 할당 진행시에는 스마트 포인터 영역이 먼저 찬다. 

따라서, test 메뉴에서 smart의 멤버 fp 함수를 실행시키기 위해서는 순서상 스마트 포인터 청크를 먼저 채우고, 
그 다음에 fp 함수를 덮어 씌워야 한다. 

그리고 스마트 포인터 값 자체는 스택영역에 저장된다 .
스마트 포인터를 참조할때는 스택에 저장된 힙 주소를 참조하여 사용하는데, 
reset 함수 진행시에 포인터 청크의 할당 해제가 이뤄지는 동시에 스택에 저장된 힙 주소도 삭제된다. 

따라서, 1번 스마트 포인터를 소멸시키더라도, 
스택에 저장된 1번 포인터의 주소가 삭제되고 1번 포인터의 힙 영역 메모리가 할당 해제되므로 
스택에 저장된 2번 포인터의 주소는 그대로 있고, 2번 포인터의 힙 영역 메모리도 그대로 있다. 

스택에 저장된 2번 포인터는 2번 포인터의 힙 영역을 참조하고, 
2번 포인터의 힙 영역에는 smart->fp()의 주소가 담겨있다. 

아까 guestbook을 write하여 할당 해제된 힙을 두번 재할당하면 smart->fp() 영역을 덮어쓸 수 있을것으로 보인다. 
해당 영역에 쉘함수 주소를 덮어씌우면 될듯. 

정리.
스마트포인터를 선언하면 힙에 스마트 포인터를 위한 영역이 할당되고 , 
스택에 각각 스마트포인터를 가리키는 주소값이 저장된다. 
그리고 이 두 스마트 포인터는 힙에 할당된 동일한 객체를 참조하고, 둘 중 하나의 스마트 포인터를 소멸시키면
해당 스마트포인터의 스택상 주소가 삭제 + 힙영역이 할당 해제, 스마트포인터가 가리키는 객체가 할당 해제 되지만 
나머지 하나에는 영향이 없고 , 나머지 하나는 여전히 할당 해제된 객체 영역을 가리키게 된다. 

그러므로, heap의 특성을 이용해 동일한 크기 청크를 재할당 하면 해당 영역에 쓰기 작업을 진행할 수 있게 되고, 
소멸되지 않은 스마트 포인터를 이용해 해당 영역을 참조하여 함수를 실행시킬 수 있단 이야기.

이런 취약점은 힙 영역에서 발생하는 취약점이기에 16.04와 18.04에선 다르게 동작할수도 있다.
tcache의 유무때문. 지금은 더블프리와 연관이 없기때문에 이대로 진행해도 된다. 










