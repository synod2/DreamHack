basic rop 64
------------
```
ubuntu 16.04
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
64비트 기반 rop . 32비트 문제와 구성은 동일하다. 0x400 만큼 rbp-0x40 위치에 입력을 받는다. 

32비트 rop와 64비트 rop의 근본적인 차이는, 함수 call 전에 인자가 어디에 배열되는지이다. 
32비트의 경우는 스택에 인자가 순서대로 배열되어있어야 하지만, 
64비트의 경우는 레지스터에 rdi ->rsi -> rdx -> rcx -> rbx -> rax 순으로 인자들이 배열되어야 한다. 

따라서 가젯도 레지스터에 스택에 있는 값을 빼오는 가젯들이 필요하다 . 
그리고 64비트의 경우는 libc base만 알아내면 one-shot-gadget의 활용이 가능하다. 

찾아보니 rdx에 관여하는 가젯이 없다. 이런 경우 return to CSU를 사용해야한다. 

csu_init에 있는 두 단계의 코드를 사용하여 레지스터에 값을 세팅하는 방법으로,
1 단계에서는 스택에 올라간 순서대로 rbx -> rbp -> r12 -> r13 -> r14 -> r15 레지스터에 값이 들어가고
2 단계에서는 r13-> rdx, r14 ->rsi, r15d -> edi 로 레지스터 안의 값이 옮겨간다. 

그 다음 r12 + rbx*8 을 연산한 결과에 대해 call 명령어를 실행한다. 
즉, r12 자리에는 다음에 실행을 원하는 함수의 주소값이 들어가면 되는데,
이때는 32비트와는 다르게 jmp가 아니라 해당 주소에 대해 직접 call을 하는 형태이기 때문에 plt대신 got주소가 들어가야 한다.  

즉, rbx -> rbp -> 함수주소 -> rdx -> rsi -> rdi 레지스터순으로 원하는 값을 스택에 넣어준 다음,
2단계에 걸쳐 rop를 진행하면 원하는 함수가 실행되는 것. 

이때 주의할 점은, rdx 레지스터 까지만 세팅이 가능하기 때문에 
인자가 4개 이상인 함수를 사용하게 될 경우는 다른 가젯도 함께 써야한다. 
그리고 2단계 코드의 종료조건이 rbx+1 과 rbp가 같을때 이므로, 
이를 이용한 연속적인 코드 실행도 고려하여 rbx와 rbp 레지스터를 세팅해주면 된다.










