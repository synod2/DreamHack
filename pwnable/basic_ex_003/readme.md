basic ex 003
------------
```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

일단 쉘을 실행시키는 함수가 존재하고, 

main 함수에서는 0x80 바이트만큼 malloc을 통해 동적할당을 받고 포인터를 ebp-0x8 위치에 저장한다 .

그 다음 , read함수를 통해 동적할당 받은 영역에 문자열을 입력한 다음 sprintf 함수가 실행되는데,

이떄 sprintf 함수의 인자로 넘어가는기 위해 스택에 쌓이는건 아까 입력한 문자열이 담긴 주소와 ebp-0x98 스택위치 주소이다. 

그리고 sprintf 함수 사용시에 서식문자를 쓰지 않고 변수 자체롤 바로 인자로 사용하고 있다. fsb가 유발될 수 있는것.

이렇게 되면 서식문자를 쓰는 경우에 그 서식문자에 해당하는 메모리 위치의 값이 서식문자 형식에 맞는 문자열의 형태로 스택에 저장된다. 

이를 이용해 서식문자를 적당히 써서 스택 크기를 불리고, 쉘 함수를 ret 위치에 넣으면 될것 같다. 

0x98만큼 채워야 하는데 입력 가능값은 0x80이니, 바이트수를 잘 계산해서 넣어보자.

* %x 문자를 하나 사용하면 4바이트 메모리를 읽어와서 숫자로 출력한다. 
* 이는 총 8 글자의 문자열로 취급되어 스택으로 들어가므로, %x 서식문자 하나당 8바이트의 메모리를 채우는 셈 .






