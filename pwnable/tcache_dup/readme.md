tcache-duplicate
----------------
```
Ubuntu 18.04
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

우분투 18.04부터 적용된 glibc 2.27 버전에서 발생할 수 있는 tcache-duplicate 문제. 
tcache의 원리는 간단하다. fastbin, largebin등등의 청크드을 바로 bin list 로 보내는게 아니고 
tcache entry 라는 별도 양방향 연결리스트에 저장하여 사용하는것.

동작 방식 자체는 다른 bin list와 동일한데, 크기별로 7개밖에 사용하지 못한다는 특징이 있고
7개를 넘어가면 원래 사이즈의 bin list를 사용하게 된다. 

tcache duplicate 공격 기법은 tcache에서 더블프리 발생시에 진행할 수 있는 기법으로, 
할당 해제된 메모리 청크가 티캐시 리스트에 올라갈 때 다음번 리스트의 주소값을 가지게 되는데, 
더블프리가 발생하면 자기 자신을 가리키게 만들 수 있어 
이미 할당했더라도 다음번 할당때 또 해당 메모리 영역에 할당을 진행하게 된다. 

다른 힙 기법들에 비하면 간단하게 사용할 수 있지만, 
2.29버전 이후부터는 사용하기가 까다롭게 된 기법이어서 잠깐 쓰이고 거의 안보이더라. 
그러나 이 기법을 공부하면 tcache 동작 구조 전반적인걸 알 수 있어서 예전에 공부했을때는 신기하고 재밌었다. 

바이너리를 보면, malloc을 진행하는 create 함수와 free를 진행하는 delete 함수가 존재한다. 
간단하게 생각하면, 메모리 청크 하나를 연속으로 2번 free 한 다음 동일한 크기의 메모리를 재 할당하면
할당 해제된 메모리 공간에 값을 쓸 수 있는데, 
티캐시에는 해당 메모리의 포인터가 아직 남아있으므로 이때 fd값을 변조하게 되면 
다음번 티캐시를 이용한 메모리 할당시에 변조한 fd값이 다시 티캐시에 올라가게 된다. 
그러므로, 그 다음번 할당시에는 fd가 가리키는 메모리 영역에 write가 가능해지는것. 

write시 힙 함수들의 hook이나 got를 덮어쓸 수 있는데, 
이 문제는 relro가 partial이므로 got overwrite가 가능하다. 
shell 함수의 주소도 존재하는 상황이므로, 적당히 printf 함수의 got를 덮어씌워주자. 

순서는 이렇다.
1. 동일한 메모리에 대해 2번의 할당 해제 진행
2. 다음번 할당시 printf함수의 got를 해당 청크의 bk 영역에 넣음
3. 더미 데이터 할당 진행. tcache의 bk위치의 printf 함수의 got가 들어있다가,
할당이 진행되면서 빠져나와 다시 tcache 리스트로 들어가 다음번 할당시에 printf의 got영역에 할당이 일어나게 만든다. 
4. printf의 got 위치에 쓰기를 원하는 주소 작성. 이 문제는 shell 함수를 선언해줬으니 그 함수의 주소를 넣었다. 

이제 해제-할당이 완료되고 printf 함수가 실행되면 쉘이 떨어진다. 

