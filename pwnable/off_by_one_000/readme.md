off by one 000
-------
```
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
```

쉘코드 실행 함수 존재함.

문자열을 전역변수 영역에 0x100바이트 입력받고. 이후 cpy 함수에서 스택 ebp-0x100 위치에 0x100 바이트 복사함

그냥 생각하면, 딱 입력받은 만큼만 복사하기에 취약점이 없는것 처럼 보인다. 한번 0x100 바이트를 꽉 채워서 보내보자 .

웃긴게, 복사는 스택에 해놓고 출력은 전역변수에서 한다.

아무튼 , 스택의 0x100 위치부터 0x100바이트를 복사하게 되면 언뜻보면 별 문제가 없이 잘 되는것 같지만, 
복사한 마지막 문자열 맨 뒤에는 널바이트가 붙게 되면서 문제가 발생한다. 

왜냐,  strcpy () 함수는 dest가 가리키는 버퍼에 마지막에 **null 바이트 ( '\ 0')를 포함하여** 복사한다.
즉, 한바이트를 덧붙인다는 소리. 따라서 0x100이 아닌 0xff 까지만 복사해도 마지막 개행문자인 \x0a 가 추가되어 복사되기 떄문에 에러가 발생할 수 있다. 

이렇게 마지막에 널바이트가 붙으면 어떤일이 일어나는지 확인해보자.
할당받은 0x100 위치 바로 다음에는 현재 함수에서 쌓인 ebp가 위치하는데 이 안에 들어있는건 아전 함수의 ebp 값이다 

즉, 이 함수가 종료된 후 마저 실행될 원본함수 ebp의 마지막 바이트가 00으로 채워져 버리는 것.

따라서, main 함수로 돌아갔을 경우 ebp가 원래 가리켜야 할 위치가 아닌 이상한곳을 가리키게 된다. 
이게 어디서 문제가 생기냐 확인해보면 함수 에필로그의 leave 명령어 부터이다. 
leave 명령어는 ebp**레지스터** 값을 esp에 복사하고 스택 제일 위의값을 다시 ebp에 넣는다. 

현재 **스택의** ebp위치에는 **이전함수의** ebp가 들어있고, 
스택의 ebp 위치를 가리키는 ebp레지스터가 esp에 복사되는 시점에서 
esp가 가리키는 곳이 스택의 제일 위고, esp는 스택의 ebp위치를 가리키고 있으므로
스택의 제일 위에는 이전함수의 ebp가 들어있게 된다.

즉 , main 함수로 돌아갈 때 ebp레지스터에 원래 들어있어야 할 값 대신 다른값이 들어가게 되는것.
다만 이는 cpy 함수가 종료될 때는 별 영향이 없다. esp는 원래대로 돌아왔기 때문에 
ret 명령어가 실행되더라도 원래대로 함수의 ret가 pop eip ,jmp eip 에 의해 정상적으로 실행된다.

cpy 함수가 끝나고 main함수로 돌아가는 시점에 
leave에서 ebp위치에 있는 값이 망가지면 main 함수로 돌아갔을떄 ebp가 손상된 상태가 된다. 
따라서, main함수의 leave가 실행 될 때 ebp는 이상한곳을 가리키고 있는 상태이므로 
leave 명령어 이후에 esp는 스택의 ebp 위치가 아닌 다른곳을 참조하게 된다는 뜻. 

이는 leave 다음의 ret 명령어를 실행할 때 그 효과가 발휘된다.
ret는 pop eip, jmp eip 이므로 스택의 제일 위, 현재 esp가 가리키는 위치에서 pop을 진행한다.
아까 ebp가 손상된 상태에서 leave가 실행되므로 esp 또한 엉뜽한 위치를 가리키게 되고, 
이상태에서 pop을 실행하면 역시나 엉뚱한 위치에 있는 값을 가져와 eip로 복사한다. 
따라서 main함수가 종료된 이후 엉뚱한 명령을 실행하게 되는것. 

이를 종합하여 페이로드를 정리해보자. 
strcpy이후 스택 ebp의 마지막이 00으로 채워지게 되면 스택의 특정 위치를 가리키게 된다. 
따라서 해당 위치에 원하는 주소값을 집어넣으면
main함수 ret가 실행 될 때 그 위치에 들어있는 주소를 참조하여 명령어를 실행하게 된다. 

이경우는 그냥스택 전체에 쉘함수 주소를 박아 스택상 위치가 바뀌더라도 왠만한 경우는 해당 값을 가져오게 만들었다.







