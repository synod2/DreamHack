cpp container 1 
----------------
```
Ubuntu 16.04.6 LTS
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE disabled
```

cpp 에서 사용하는 컨테이너(벡터, 큐 , 스택등과 같은 자료형을 사용할 수 있게 cpp에서 제공하는 형태.) 
에서 발생할 수 있는 취약점에 대한 문제.

해당 컨테이너 형태로 사용하는 변수들의 경우는 사용자가 직접 할당한 메모리와 다르게 추상화되어있고 
상세한 조정이 들어있지 않아 사용시에 주의를 요한다. 

해당 컨테이너 변수를 인자로 하여 메모리를 복사하거나 할당하는 함수들을 사용할 때
초기화나 크기 지정이 없이 사용하는경우에 버퍼 오버플로우가 유발될 수 있기 때문.

바이너리를 보면, 생성, 크기 수정, 복사, 출력 의 네가지로 구성되어있다. 
두 컨테이너에 입력을 받는데, 기본적으로는 크기 3으로 지정되어 있어 맨처음에 생성하면 3개씩 입력을 받는다. 

크기가 달라도 복사가 가능한것처럼 보이지만, 컨테이너1의 크기가 일정 이상이면 복사시에 에러가 발생한다. 

프로그램 구조를 보자.

menu를 호출할 때 Menu구조체의 fp 포인터에 print_menu 함수의 주소를 복사해놓고, 
반복문이 종료될 때 마다 menu->fp() 의 형태로 print_menu 함수를 호출하고 있다. 

이때 menu 구조체는 힙 영역에 선언된 상태로, print_menu함수의 주소도 해당 메모리 종간에 저장되어있다. 
또, 컨테이너 변수 두개도 힙 영역에 값을 저장하고 있다. 
각각 0x20 바이트씩 영역을 할당받아 사용하며, 컨테이너의 크기를 변경할 시 기존 힙은 할당 해제되고, 
새로운 크기의 힙이 할당된다. 

그러나 크기가 다른 힙끼리 복사가 가능하므로, 
이를 이용하면 container2의 영역을 넘어가 menu 구조체를 덮어쓸 수 있게 된다. 
보니까 resize 함수가 내부적으로는 새로 할당 -> 할당해제 -> 값 복사 의 루틴을 지니는것 같다. 
같은 size, 혹은 기존보다 작은 size를 인자로 하여 실행시엔 별도의 동작을 안하는듯. 
(여기서 힙 취약점도 유발해볼 수 있을듯?)

std::copy함수는 컨테이너의 원본 iter 처음, 끝, 목표 iter 처음 을 각 인자로 하여 복사를 진행하는데, 
목표 iter의 끝은 지정하지 않기 때문에 size가 다른 경우엔 오버플로우가 발생하는 모양. 

아무튼, 9번째 값이 복사될 때 menu의 fp가 덮어 씌워지며, 
반복문 내에서 menu 함수가 호출되는 대신 해당 위치에 있는 포인터에 call을 실행한다. 

따라서,두 컨테이너의 크기를 각각 9,3으로 바꾸고, 
컨테이터1의 9번째 값을 쉘 함수 주소로 바꾼 뒤 컨테이너 2에 복사하면 
다음번 menu 호출시에 쉘이 떨어진다. 








